import numpy as np
import cv2
from pseyepy import Camera, Display
from PIL import Image
from labjack import ljm
import multiprocessing as mp
import tifffile as tf
import os
from datetime import datetime
import time as time
import socket
import csv
from copy import deepcopy

def showVideo(q_list, num_cams, folder_name):
    
    try:
        for i in range(num_cams):
            os.mkdir("./images/"+folder_name+"/"+str(i))
    except:
        pass

    # cv2.startWindowThread() # starts display window

    q_closed = 0
    while True:
        frames = []
        try:
            top = q_list[0].get()
            if top == "END": # end signal from queue
                break
            frames, timestamp = top # pull first frame off of queue
            for j in range(num_cams):
                name = "./images/"+folder_name+"/"+str(j)+"/"+ str(timestamp[j]) + ".tif"

                    # cv2.imshow("display"+str(j), frame)
                    # frames.append(frame)
                    #cv2.waitKey(1)

                tf.imwrite(name, frames[j], timestamp[j]) # writes output with timestamp
        except:
            pass
    print(q_list[0].qsize(), " images left in the Queue.")
    print("Finished saving images.")

def getVideo(q_list, num_cams):

    c = Camera(range(num_cams), fps=[70]*num_cams, resolution=[Camera.RES_LARGE]*num_cams, colour=[False]*num_cams) # opens camera
    f0, t0 = c.read()
    print("Opened cameras successfully.")

    while q_list[-1].empty():
        if q_list[1].empty():
            frames, times = c.read()
            q_list[0].put((np.copy(frames), times))

    print("Finished capturing frames.")
    
    q_list[0].put("END") # end signal
    c.end()

def socketHelper(TCP_IP, TCP_PORT):
    if TCP_IP == "":
        TCP_IP = "152.2.174.197"
    if TCP_PORT == "":
        TCP_PORT = 12346

    serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    serverSocket.bind(("", int(TCP_PORT)))
    # serverSocket.connect(("", TCP_PORT))

    serverSocket.listen()

    clientSocket, clientAddress = serverSocket.accept()
    print('Connected by', clientAddress)
    return serverSocket, clientSocket, clientAddress

def listenTCPIP(q_list, folder_name, sig, clientSocket, clientAddress, serverSocket):

    # serverSocket, clientSocket, clientAddress = socketHelper()
    clientSocket.settimeout(1.0)

    f = open("./images/"+folder_name+"/times.csv", "a")
    writer = csv.writer(f, delimiter=',', quotechar='"')

    chunks = bytearray(8)
    count = 0
    while q_list[-1].empty():
        bytes_recvd = 0
        try:
            wait_count = 0       
            while bytes_recvd < 4 and wait_count < 8:
                chunk = clientSocket.recv(min(8 - bytes_recvd, 2048))
                try:
                    q_list[1].get_nowait()
                except:
                    pass
                t = time.time()

                chunks[bytes_recvd:bytes_recvd+len(chunk)] = chunk
                bytes_recvd += len(chunk)
                wait_count += 1
            
            number = np.frombuffer(chunks,dtype='<u2')%(2**32)
            if count%100 == 0:
                print(number)
            writer.writerow([t, number])
            count += 1
        except socket.timeout:
            if sig.empty():
                if q_list[1].empty():
                    q_list[1].put(1)
                print("Timed out, reconnecting...")
            else:
                sig.get()
                print("Closing TCP_IP connection...")
                break

    if q_list[-1].empty():
        print("Queue is empty.")

    # while q.empty():
        # msg = serverSocket.recv()
        # if len(msg) > 0:
            # writer.writerow([datetime.now(), msg])
    f.close()
    clientSocket.close()
    serverSocket.close()

    # print("Exited listenTCPIP process.")

def getLabjack(q):
    print("labjack process")
    handle = ljm.openS("ANY", "ANY", "ANY")

    name = ["AIN0"]
    aScanList = ljm.namesToAddresses(1, name)[0]
    scanRate = 1000
    scansPerRead = int(scanRate / 2)

    ljm.eWriteName(handle, "STREAM_TRIGGER_INDEX", 0)
    ljm.eWriteName(handle, "STREAM_CLOCK_SOURCE", 0)

    aNames = ["AIN_ALL_NEGATIVE_CH", "AIN0_RANGE",
                  "STREAM_SETTLING_US", "STREAM_RESOLUTION_INDEX"]
    aValues = [ljm.constants.GND, 10.0, 0, 0]

    numFrames = len(aNames)
    ljm.eWriteNames(handle, numFrames, aNames, aValues)

    scanRate = ljm.eStreamStart(handle, scansPerRead, 1, aScanList, scanRate)

    start = datetime.now()
    totScans = 0
    totSkip = 0

    i = 0
    while q_list[-1].empty:
        ret = ljm.eStreamRead(handle)

        aData = ret[0]
        scans = len(aData)
        curSkip = aData.count(-9999.0)
        totScans += curSkip

        print(aData[0])
        i += 1
    
    ljm.close(handle)

if __name__ == "__main__":
    num_cams = int(input("Enter number of cameras: "))
    addr = input("Enter client IP address: ")
    port = input("Enter port for connection: ")

    ########## Getting correct folder name ###########
    serverSocket, clientSocket, clientAddress = socketHelper(addr, port)

    serverSocket.settimeout(5.0)

    try:
        chunk=""
        while not len(chunk) > 0:
            chunk = clientSocket.recv(2048)
        folder_name = chunk.decode('utf-8')
        print("Folder Name: " + folder_name)
    except:
        folder_name = input("Enter folder name: ")
    os.mkdir("./images/"+folder_name+"/")

    #clientSocket.close()
    #serverSocket.close()

    # c = Camera(range(num_cams), fps=[70]*num_cams, resolution=[Camera.RES_LARGE]*num_cams, colour=[False]*num_cams)

    q_list = [mp.Queue()] # This queue keeps track of frames from the cameras
    q_list.append(mp.Queue()) # This queue keeps track of start/stop
    q_list.append(mp.Queue()) # This queue signals when to stop the frame collection
    q_list[1].put(1)

    end_signal = mp.Queue() # This queue signals when to shut off the TCP_IP connection(s)

    pget = mp.Process(target=getVideo, args=(q_list, num_cams, ))
    pshow = mp.Process(target=showVideo, args=(q_list, num_cams,folder_name, ))
    ptcpip = mp.Process(target=listenTCPIP, args=(q_list, folder_name, end_signal, clientSocket, clientAddress, serverSocket, ))
    # plabjack = mp.Process(target=getLabjack, args=(q_list[-1], ))
    
    # plabjack.start()
    
    ptcpip.start()
    pget.start()
    pshow.start()

    i = input("Press enter to stop collection.\n")
    q_list[-1].put(i)

    pget.join()
    pshow.join()
    end_signal.put(1)
    # print("end signal sent")
    ptcpip.join()
    # print("joined2")
    # plabjack.join()
    # print("joined3")
